#!/usr/bin/perl -w
#
# Copyright 2002-2013, Stephen Fryatt (info@stevefryatt.org.uk)
#
# This file is part of ManTools:
#
#   http://www.stevefryatt.org.uk/software/
#
# Licensed under the EUPL, Version 1.1 only (the "Licence");
# You may not use this work except in compliance with the
# Licence.
#
# You may obtain a copy of the Licence at:
#
#   http://joinup.ec.europa.eu/software/page/eupl
#
# Unless required by applicable law or agreed to in
# writing, software distributed under the Licence is
# distributed on an "AS IS" basis, WITHOUT WARRANTIES
# OR CONDITIONS OF ANY KIND, either express or implied.
#
# See the Licence for the specific language governing
# permissions and limitations under the Licence.

# ManTools -- Convert help-markup into readable files.
#
# Usage: ManTools -M<TEXT|HTML|STRONG|DDF> -I<infile> -O<outfile> [-D<var>=<val> ...]

use Tree::Simple;

use strict;

use constant TRUE		=> 1;
use constant FALSE		=> 0;

use constant LIST_NONE		=> 0;
use constant LIST_BULLET	=> 1;
use constant LIST_NUMERIC	=> 2;
use constant LIST_UPPER		=> 3;
use constant LIST_LOWER		=> 4;


# Formatting variables.

my $output_preformatted = FALSE;

my %defs = ("title", "");

# Process the command line arguments.

my $infile = undef;
my $outfile = undef;
my $mode = undef;

foreach my $arg (@ARGV) {
	if ($arg =~ /^-I(.+)/) {
		$infile = $1;
	} elsif ($arg =~ /^-O(.+)/) {
		$outfile = $1;
	} elsif ($arg =~ /^-M(.+)/) {
		$mode = uc($1);
	} elsif ($arg =~ /^-D([^=]+)=(.*)/) {
		$defs{$1} = $2;
	}
}

if (!defined($mode) || !defined($infile) || !defined($outfile)) {
	die "Missing mode, input or output filename parameters.\n";
}

# Validate the specified output mode.

my $found = FALSE;

foreach my $item (("HTML")) {
	if ($item eq $mode) {
		$found = TRUE;
	}
}

if (!$found) {
	die "Invalid Mode.\n";
}

# Open the input and output files -- there is only one output file used.

my $parse_tree = Tree::Simple->new({object => 'Root'}, Tree::Simple->ROOT);
my $current_node = $parse_tree;

open(INPUT, $infile) || die "Can't open input file $infile: $!\n";
open(OUTPUT, ">".$outfile) || die "Can't open output file $outfile: $!\n";

# Read the lines in one at a time and process them.

while (defined(my $line = <INPUT>)) {
	chomp($line);

	if ($line =~ /^\s*<([^<>]*)>\s*$/) {
		my %params = parse_tag($1);

		if ($params{'tag_name'} eq 'define') {
			# If it's already defined, then either we've defined it twice in the file,
			# or the file definition has been overridden by a command line definition.

			if (defined($params{'name'}) && defined($params{'value'}) && !defined($defs{$params{'name'}})) {
				$defs{$params{'name'}} = $params{'value'};
			}
		} elsif ($params{'tag_name'} eq 'chapter') {
			if (!defined($params{'title'})) {
				$params{'title'} = "Chapter";
			}
			$current_node = Tree::Simple->new({object => 'Chapter', %params}, $current_node);
		} elsif ($params{'tag_name'} eq '/chapter') {
			$current_node = $current_node->getParent;
		} elsif ($params{'tag_name'} eq 'literal') {
			my $literal = "";
			my $literal_line = "";

			if (!defined($params{'mode'})) {
				$params{'mode'} = "";
			}

			while (defined ($literal_line = <INPUT>) && $literal_line !~ /^<\/literal>$/) {
				if (uc($params{'mode'}) eq uc($mode)) {
					while ($literal_line =~ /\$\$([a-z]+?)\$\$/) {
						$literal_line = "$`$defs{$1}$'";
					}

					$literal .= $literal_line;
				}
			}

			if ($literal ne "") {
				Tree::Simple->new({object => 'Literal', content => $literal}, $current_node);
			}
		} elsif ($params{'tag_name'} eq 'subhead') {
			if (!defined($params{'title'})) {
				$params{'title'} = "Subheading";
			}
			Tree::Simple->new({object => 'Subhead', %params}, $current_node);
		} elsif ($params{'tag_name'} eq 'codeblock') {
			$current_node = Tree::Simple->new({object => 'CodeBlock'}, $current_node);
			$output_preformatted = TRUE;
		} elsif ($params{'tag_name'} eq '/codeblock'){
			$current_node = $current_node->getParent;
			$output_preformatted = FALSE;
		} elsif ($params{'tag_name'} eq 'box') {
			$current_node = Tree::Simple->new({object => 'Box', %params}, $current_node);
		} elsif ($params{'tag_name'} eq '/box') {
			$current_node = $current_node->getParent;
		} elsif ($params{'tag_name'} eq 'list') {
			if (node_is($current_node, 'ListItem')) {
				# If this is a nested list, close the parent list item before nesting.
				$current_node = $current_node->getParent;
			}
			$current_node = Tree::Simple->new({object => 'List', %params}, $current_node);
		} elsif ($params{'tag_name'} eq '/list') {
			if (node_is($current_node, 'ListItem')) {
				# If we're in a list item, end it first.
				$current_node = $current_node->getParent;
			}
			$current_node = $current_node->getParent;
		} elsif ($params{'tag_name'} eq 'definition') {
			if (!defined($params{'target'})) {
				$params{'target'} = "Definition";
			}
			$current_node = Tree::Simple->new({object => 'Definition', %params}, $current_node);
		} elsif ($params{'tag_name'} eq '/definition') {
			$current_node = $current_node->getParent;
		} elsif ($params{'tag_name'} eq 'comdef') {
			my $command = "";
			if (defined($params{'target'})) {
				$command = "\n<dl><dt><b>".$params{'target'}."</b>";
			} else {
				$command = "\n<dl><dt><b>Command</b>";
			}
			if (defined($params{'params'})) {
				$command .= " <i>".$params{'params'}."</i>";
			}
			$command .= "</dt>\n<dd>\n";
			$current_node = Tree::Simple->new({object => 'ComDef', %params}, $current_node);
		} elsif ($params{'tag_name'} eq '/comdef') {
			$current_node = $current_node->getParent;
		}
	} elsif ($line !~ /^\s*$/  || $output_preformatted) {
		if ($line =~ /^<li>/) {
			if (node_is($current_node, 'ListItem')) {
				# If we're already in a list item, end it before starting a new one.
				$current_node = $current_node->getParent;
			}
			$current_node = Tree::Simple->new({object => 'ListItem'}, $current_node);

			$line =~ s/^<li>//;
		}
		Tree::Simple->new({object => 'Paragraph', content => $line}, $current_node);
	}
}

# Turn the tree into the requested output.

if ($mode eq "HTML") {
	$parse_tree->traverse(\&html_open, \&html_close);
}


# -------------------------------------------------------------------------------------------------
# Process a node for HTML output.
#
# Param: $node			The node to process.

sub html_open
{
	my ($node) = @_;
	my $parent = $node->getParent;
	my $object = $node->getNodeValue()->{'object'};

	if ($object eq 'Literal') {
		print OUTPUT get_value($node, 'content');
	} elsif ($object eq 'Chapter') {
		print OUTPUT "\n<div><a name=\"".get_value($node, 'file')."\"></a><h2>".get_value($node, 'title')."</h2>\n";
	} elsif ($object eq 'Subhead') {
		print OUTPUT "\n<h3>".get_value($node, 'title')."</h3>\n";
	} elsif ($object eq 'List') {
		if (lc($node->{'type'}) eq 'num') {
			print OUTPUT html_opening_nl($node)."<ol type=\"1\">";
		} elsif (lc($node->{'type'}) eq 'upper') {
			print OUTPUT html_opening_nl($node)."<ol type=\"A\">";
		} elsif (lc($node->{'type'}) eq 'lower') {
			print OUTPUT html_opening_nl($node)."<ol type=\"a\">";
		} else {
			print OUTPUT html_opening_nl($node)."<ul>";
		}
	} elsif ($object eq 'ListItem') {
		print OUTPUT html_opening_nl($node)."<li>";
	} elsif ($object eq 'CodeBlock') {
		print OUTPUT html_opening_nl($node)."<pre>";
	} elsif ($object eq 'Box') {
		print OUTPUT html_opening_nl($node)."<div style=\"margin-left: 3em; padding: 0 0 0 52px; border-left: 5px solid gray; overflow: hidden;\">";
		if (lc(get_value($node, 'type')) eq 'info') {
			print OUTPUT "<img src=\"info.png\" width=32 height=32 style=\"float: left; margin-left: -42px; margin-top: 0em; padding-top: 0em;\">";
		} elsif (lc(get_value($node, 'type')) eq 'warning') {
			print OUTPUT "<img src=\"warning.png\" width=32 height=29 style=\"float: left; margin-left: -42px; margin-top: 0em; padding-top: 0em;\">";
		}
	} elsif ($object eq 'Definition') {
		print OUTPUT html_opening_nl($node)."<dl><dt><b>".$node->getNodeValue()->{'target'}."</b></dt>\n<dd>";
	} elsif ($object eq 'ComDef') {
			my $command = html_opening_nl($node);
			if (defined(get_value($node, 'target'))) {
				$command .= "<dl><dt><b>".get_value($node, 'target')."</b>";
			} else {
				$command .= "<dl><dt><b>Command</b>";
			}
			if (defined(get_value($node, 'params'))) {
				$command .= " <i>".get_value($node, 'params')."</i>";
			}
			$command .= "</dt>\n<dd>";
			print OUTPUT $command;
	} elsif ($object eq 'Paragraph') {
		my $line = html_output_line(get_value($node, 'content'));

		print OUTPUT html_opening_nl($node).html_opening_p($node).$line.html_closing_p($node).html_closing_nl($node);
	} else {
		print "Node Type '".$object."'\n";
	}
}


# -------------------------------------------------------------------------------------------------
# Reprocess a node for HTML output once its children have been processed.
#
# Param: $node			The node to process.

sub html_close {
	my ($node) = @_;

	my $value = $node->getNodeValue();
	my $object = $value->{'object'};

	if ($object eq 'Chapter') {
		print OUTPUT "</div>\n";
	} elsif ($object eq 'List') {
		if (lc($value->{'type'}) eq 'num' || lc($value->{'type'}) eq 'upper' || lc($value->{'type'}) eq 'lower') {
			print OUTPUT "</ol>\n";
		} else {
			print OUTPUT "</ul>\n";
		}
	} elsif ($object eq 'ListItem') {
		print OUTPUT "</li>".html_closing_nl($node);
	} elsif ($object eq 'CodeBlock') {
		print OUTPUT "</pre>".html_closing_nl($node);
	} elsif ($object eq 'Box') {
		print OUTPUT "</div>".html_closing_nl($node);
	} elsif ($object eq 'Definition' || $object eq 'ComDef') {
		print OUTPUT "</dd></dl>".html_closing_nl($node);
	}
}


# -------------------------------------------------------------------------------------------------
# Process a line of text from the file, parsing any in-line commands and formatting it for the
# current file type.
#
# Param: $line			The line of text to be written.
# Return: 			The formatted line.

sub html_output_line
{
	my ($line) = @_;

	# <cite>, <code>, <em> and <strong> just get left as-is.

	$line =~ s/<command>(.*?)<\/command>/<code>$1<\/code>/g;	# Inline code - enclose in ""
	$line =~ s/<entry>(.*?)<\/entry>/<tt>$1<\/tt>/g;		# User entry
	$line =~ s/<file>(.*?)<\/file>/<i>$1<\/i>/g;			# Filename - no effect
	$line =~ s/<icon>(.*?)<\/icon>/<b>$1<\/b>/g;			# Icon labels - enclose in ''
	$line =~ s/<key>(.*?)<\/key>/ucfirst $1/eg;			# Key names - initial capital
	$line =~ s/<menu>(.*?)<\/menu>/<b>$1<\/b>/g;			# Menu entries - enclose in ''
	$line =~ s/<mouse>(.*?)<\/mouse>/ucfirst $1/eg;			# Mouse buttons - initial capital
	$line =~ s/<param>(.*?)<\/param>/<tt>$1<\/tt>/g;
	$line =~ s/<window>(.*?)<\/window>/<b>$1<\/b>/g;		# Window names - no effect

	# Convert all the hyperlinks into HTML format.

	while ($line =~ /<link ref="#url (.*?)">(.*?)<\/link>/) {
		$line = "$`<a href=\"$1\">$2</a>$'";
	}

	while ($line =~ /<link ref="(.*?)">(.*?)<\/link>/) {
		$line = "$`<a href=\"#$1\">$2</a>$'";
	}

	# Sort out any &msep; entities into something that's valid HTML.

	while ($line =~ /&msep;/) {
		$line = "$`&rarr;$'";
	}

	# Remove any trailing whitespace from the line

	$line =~ s/\s*$//;

	return $line;
}


# -------------------------------------------------------------------------------------------------
# Return an opening \n suitable for a node's paragraph.
#
# Param: $node			The node to return the tag for.
# Return: 			The required newline.

sub html_opening_nl
{
	my ($node) = @_;

	if (node_is($node->getParent, 'CodeBlock')) {
		return "";
	}

	return (first_node($node) && !node_is($node->getParent, 'Chapter')) ? "" : "\n";
}


# -------------------------------------------------------------------------------------------------
# Return a closing \n suitable for a node's paragraph.
#
# Param: $node			The node to return the tag for.
# Return: 			The required newline.

sub html_closing_nl
{
	my ($node) = @_;

	return (last_node($node)) ? "" : "\n";
}


# -------------------------------------------------------------------------------------------------
# Return an opening <p> tag suitable for a node's paragraph.
#
# Param: $node			The node to return the tag for.
# Return: 			The required <p> tag.

sub html_opening_p
{
	my ($node) = @_;

	if (node_is($node->getParent, 'CodeBlock')) {
		return "";
	}

	if (!node_is($node->getParent, 'ListItem', 'Box', 'Definition', 'ComDef')) {
		return "</p>";
	}

	my $margins = "";

	if (first_node($node) && last_node($node)) {
		$margins = " style=\"margin-top: 0em; margin-bottom: 0em;\"";
	} elsif (first_node($node)) {
		$margins = " style=\"margin-top: 0em;\"";
	} elsif (last_node($node)) {
		$margins = " style=\"margin-bottom: 0em;\"";
	}

	return "<p".$margins.">";

}


# -------------------------------------------------------------------------------------------------
# Return a closing </p> tag suitable for a node's paragraph.
#
# Param: $node			The node to return the tag for.
# Return: 			The required </p> tag.

sub html_closing_p
{
	my ($node) = @_;

	return (node_is($node->getParent, 'CodeBlock')) ? "" : "</p>";
}


# -------------------------------------------------------------------------------------------------
# Test to see if a node is the first of its parent's childen
#
# Param: $node			The node to test.
# Return:			TRUE if the node is the first child; else FALSE.

sub first_node
{
	my ($node) = @_;

	if ($node->getDepth == 0) {
		return FALSE;
	}

	if ($node->getIndex != 0) {
		return FALSE;
	}

	return TRUE;
}


# -------------------------------------------------------------------------------------------------
# Test to see if a node is the last of its parent's childen
#
# Param: $node			The node to test.
# Return:			TRUE if the node is the last child; else FALSE.

sub last_node
{
	my ($node) = @_;

	if ($node->getDepth == 0) {
		return FALSE;
	}

	if ($node->getIndex != $node->getParent->getChildCount - 1) {
		return FALSE;
	}

	return TRUE;
}


# -------------------------------------------------------------------------------------------------
# Test to see if a node is one of the supplied types.
#
# Param: $node			The node to test.
# Param: @types			A list of types to test against.
# Return:			TRUE if the node is one of the supplied types; else FALSE.

sub node_is
{
	my ($node, @types) = @_;

	my $found = FALSE;

	foreach my $type (@types) {
		if (get_value($node, 'object') eq $type) {
			$found = TRUE;
			last;
		}
	}

	return $found;
}


# -------------------------------------------------------------------------------------------------
# Return the value from a node's parameter hash entry.
#
# Param: $node			The node to target.
# Param: $parameter		The parameter to return.
# Return:			The value of the parameter.

sub get_value
{
	my ($node, $parameter) = @_;

	return $node->getNodeValue()->{$parameter};
}


# -------------------------------------------------------------------------------------------------
# Store a value into a node's parameter hash.
#
# Param: $node			The node to target.
# Param: $parameter		The parameter to set.

sub set_value
{
	my ($node, $parameter, $value) = @_;

	$node->getNodeValue()->{$parameter} = $value;
}


# -------------------------------------------------------------------------------------------------
# Parse a tag, returning a hash containing a set of attribute/value pairs.
# The tag is given an attribute name "tag_name".
#
# Param: $tag			The tag to be parsed (eg. "p name="value"").
# Return:			A hash of tag name and attribute values.

sub parse_tag
{
	my ($tag) = @_;
	my (%attributes, @items, $item, $name, $value);

	# Convert the spaces outside of quotes into \n and split on these.

	$tag =~ s/\s+([^="]*?=)/\n$1/g;
	@items = split(/\n/, $tag);

	foreach $item (@items) {
		($name, $value) = split(/=/, $item);

		if (defined($value) && $value ne "") {
			$value =~ s/^\s*"(.*)"\s*$/$1/; # Strip quotes and external whitespace.
			$attributes{$name} = $value;
		} else {
			$attributes{'tag_name'} = $name;
		}
	}

	return %attributes;
}

